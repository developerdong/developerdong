# 谈谈数据库事务的一致性问题

众所周知，数据库事务有ACID四大特性。
其中AID好理解，大家没有什么争论，
但是对于C(Consistency)的理解不尽相同。
综合网上的各种观点，以及我本人的理解，
我把数据库事务一致性分成了*写一致性*和*读一致性*两种，
总结如下。

## 写一致性

写一致性可以理解为事务对数据进行插入、删除、
修改时需要满足各种规则，例如约束、级联、触发器。

拿经典的银行转账来举例：
1. 首先我们添加一个约束，要求每个账户的钱不能小于0；
2. 小明账户里有90元钱，小红账户里有0元钱；
3. 小明先转90元给小红，此时小明账户里有0元钱，小红账户里有90元钱；
4. 小明再转10元给小红，此时小明账户里有-10元，小红账户里有100元。

因为要保证写一致性，所以第4步不能执行，这个事务是不能提交的。

这里需要注意的是，不能将原子性和一致性混淆：
- 如果数据库允许此事务提交，则此时是满足原子性的（
因为操作全都执行了），但是因为小明账户里的钱小于0，
所以不满足一致性。
- 如果第3步执行完，连接断开了，
则此时数据库状态是满足一致性的，但该事务不满足原子性，
为了保证原子性，就必须回滚事务。

## 读一致性

读一致性可以理解为事务读取的数据没有处于中间状态。

在读已提交及以上级别，因为读取的数据都是提交后的数据，
不会读取到另一个事务处于中间状态的数据，
所以在这些隔离级别下，读一致性是可以保证的。
但是在读未提交级别，因为允许脏读，
所以不能保证读一致性，是否读到处于中间状态的数据是随机的。

在MySQL中，“读已提交”和“可重复读”级别通过MVCC解决了脏读问题，
所以这两个级别中的读被称为Consistent Read，即“一致性读”；
而“读未提交”没有解决脏读问题，所以不是“一致性读”。

## 总结

综上所述，数据库事务的一致性可以总结为如下两点：
1. 写数据时满足各种定义的规则；
2. 读数据时不会读到处于中间状态的数据。