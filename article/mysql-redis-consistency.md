# 一种MySQL和Redis保证最终一致性的同步方案

最近在网上看了一些讲MySQL和Redis如何同步的文章，
这些文章互相抄来抄去，提到了双删之类的方法。
但我读了之后，觉得双删并没有解决问题，这些文章给出的解释都不太靠谱，
所以自己思考了一下，并把方案记录下来。不保证一定正确，
但自我感觉比网上互相抄来抄去的文章中的方法要靠谱多了。

首先看图：

![mysql-redis-consistency drawio](https://user-images.githubusercontent.com/15864936/150296790-9b00abf1-f181-406b-9f16-c1985a54afa4.png)


我特地将图中不同部分用不同的颜色标了出来，下面记录一下不同部分的操作和思考。

## 读业务端的操作

1. 读业务端查询redis，如果查到了，直接返回。
2. 如果在redis没查到，则去查询mysql，然后向kafka写消息，这里的消息只是一个通知，
更新器拿到消息后去查询数据库、更新缓存，消息里只携带缓存key，并不包括从mysql查到的结果，
这里“不携带查询mysql的结果”是个关键。当多个业务端查询同一key
失败时，他们只是写通知消息到kafka，并不会去更新redis，所以也就不存在写redis时的
并发问题了。同时因为消息中“不携带查询mysql的结果”，所以这个通知消息也是不怕乱序的，
多个读业务端并发写同一key的通知消息到kafka，不会产生问题。

另外，如果担心“缓存击穿”问题，并且对缓存更新延迟容忍度较高，
甚至可以不查mysql，只写通知到kafka，等待缓存更新。

## canal部分的操作

1. 读binlog。
2. 写通知消息到kafka。

canal部分就比较简单，只要数据库有记录被更新、删除，就会产生通知消息。

## 更新器的操作

1. 从kafka读通知消息，这里根据消息中的key，将消息划分到不同分区。
2. 更新器根据消息中的key，查询数据库，同时这里如果有连续多条相同消息，只需要查询数据库一次。
3. 根据查询结果更新缓存，如果没查到数据，可以选择清空缓存中的相应key，或者value置空。

这部分的关键点在于虽然多更新器实例是并发的，但从key的视角看，相同
key的消息会被放到同一分区，最终被同一消费者消费，所以只会有一个消费者
去更新同一个key，也就不存在并发更新key产生的问题。

而且消息是不怕重复消费的，如果消费了一条消息，还没有提交偏移量，
更新器就挂掉了，重启之后又拿到同一条通知消息，也不过是又启动了
一次查数据库、更新缓存的流程，对数据正确性没有任何影响。

## 写业务端的操作

写业务端就很简单，直接写数据库就行了，不去直接更新缓存。

## 总结

总体来看，最关键的思想就是从设计上避免一个key的并发更新。
让更新器负责缓存更新，其他组件就只是通知更新器进行更新，而不能自己进行更新操作。

